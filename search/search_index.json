{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"nebula-design-concepts/","text":"Data modeling and design concept \u00b6 Nebula Graph is comprised of four components: storage layer, metadata service, computation layer and client console. In this documentation, we'll discuss data modeling and architecture of Nebula Graph. Directed property graph \u00b6 Modeling data with directed property graph, Nebula Graph is very easy to understand, i.e. Nebula Graph consists of two graph elements: vertex and edge. Each vertex represents an entity, and each edge represents how two vertices are associated. Vertex, type of vertex (tag) and the corresponding vertex properties \u00b6 In Nebula Graph, the type of vertex is called tag . A vertex must have at least one type (tag) or multiple types (tag). Each tag has a corresponding set of properties called schema. Consider the above picture as example, there are two types of vertices: player and team . Vertex player's schema has three properties: id (vid), Name(string), and Age(int); vertex team's schema has two properties: id (vid) and Name(string). Like Mysql, Nebula Graph is a strong schema database. The property name and data type are determined before the data is written. Edge, edgetype and the corresponding edge properties \u00b6 Edges in Nebula Graph always have a type, a start (src)and an end vertex (dst), and a direction. They can be self-referencing/looping but can never be dangling (missing a start or end node). Each edge has an edgetype, and each edgetype defines the properties of the edge. In the preceding example, there are two kinds of edges, one is like pointing from player to player, the property is likeness (double); the other is serve , pointing from team to serve, the properties are start_year(int) and end_year(int). It should be noted that there may be multiple edges of the same or different types at the same time between the start (src)and end vertex (dst). Graph partition \u00b6 Since the number of vertices in a super large-scale relational network can reach to dozen billions or trillions, and the number of edges can even be dozen trillions, the storage of both will exceed the capacity of a general server. Therefore, a method is needed to cut the graph elements and store them on different logical partitions. Nebula Graph conducts edge splitting to make partitions, and its default strategy is Hash. The number of partitions is static and cannot be changed. Data model \u00b6 In Nebula Graph, each vertex is modeled as key-values, then stored to the corresponding partition after hashing according to its vertexID. An edge is modeled as two separate key-values in Nebula Graph, i.e. out-key and in-key, respectively. The out-key and the edge's corresponding starting point are stored in one partition, while the in-key and end point are stored in another one. Architecture \u00b6 Nebula Graph includes four modules: storage layer, metadata service, computation layer and client console. Storage layer \u00b6 The corresponding process of storage layer is nebula-storaged, and its core is the distributed Key-value Storage based on RAFT protocol. Currently it supports multiple storage engines like Rocksdb and HBase, etc. Raft protocol ensures data consistency by leader/follower mechanism. Based on that, Nebula Storage makes the following optimizations: Parallel Raft Partitions of same ID from multiple machines form a raft group. And the concurrent operations are implemented with multiple sets of Raft groups. Write Path & batch In Raft protocol, multi-machine synchronization depends on log ID orders, which lead to low throughput. Nebula achieves high throughput by batch and out-of-order submission. Copy learner based on synchronism When added to cluster, new machines will be tagged as learner and pull data from leader/follower synchronically. The learner will be tagged as follower and participate in Raft protocol when it catches up leader. Load-balance For machines with high stress, migrate the partition they serve to machines with low stress for better load balancing. Metadata service \u00b6 The process corresponding to the Meta service is nebula-metad, and its main functions are: User management Nebula Graph's user system includes God user, Admin, User, and Guest, each is different in operating privileges. Cluster configuration management Support online and offline new servers. Graph space management Add, drop graph space, modify graph space configuration (Raft copies) Schema management Nebula Graph is a strong schema database. Types of Tag and Edge properties are recorded by Meta service. Supported types are: int, double, timestamp, list, etc. Multi-version management, supporting adding, modifying and deleting schema, and recording its version. TTL (time-to-live) management, supporting automatic data deletion and space reclamation. The Meta Service layer is state, and just like the Storage layer, it maintains state persistence through KV Store. Query Engine & Query Language (nGQL) \u00b6 The process corresponding to the computation layer is nebula-graphd, which consists of computing vertices that are fully equal, stateless, and unrelated. There is no communication among the computing vertices. The main function of the Query Engine layer is to analysis the nGQL text sent by the client and generate an execution plan through lexical analysis (Lexer) and parsing (Parser). Then the execution plan will pass to the the execution engine. The execution engine obtains the schema of the graph vertices and edges through the Meta Service, then obtains the data of the vertices and edges through the storage engine layer. The main optimizations of the Query Engine layer are: Asynchronous and concurrent execution Since both IO and network are long-latency operations, asynchronous and concurrent operations are required. In addition, to avoid a single long query affecting subsequent queries, a separate resource pool is set for each query to guarantee quality of service (QoS). Push down Too much data passing back form storage layer to computation layer occupies too much bandwidth, to avoid that, operators such as conditional filtering (where) are sent to the storage layer along with the query filters. Execution plan optimization Execution plan optimization in relational database SQL has experienced a long period but research on the optimization of graph query language is relatively less. Nebula Graph also makes some exploration on the execution plan optimization of graph query, including executing plan cache and the concurrent execution of the context-free queries. API and SDK \u00b6 Nebula Graph provides SDKs in C++, Java, and Golang. Nebula Graph uses RPC to communicate among servers, and the communication protocol is Facebook-Thrift. Users can also use Nebula Graph on Linux. Nebula Graph's web SDK is in progress and will be released soon.","title":"Data modeling and design concept"},{"location":"nebula-design-concepts/#data-modeling-and-design-concept","text":"Nebula Graph is comprised of four components: storage layer, metadata service, computation layer and client console. In this documentation, we'll discuss data modeling and architecture of Nebula Graph.","title":"Data modeling and design concept"},{"location":"nebula-design-concepts/#directed-property-graph","text":"Modeling data with directed property graph, Nebula Graph is very easy to understand, i.e. Nebula Graph consists of two graph elements: vertex and edge. Each vertex represents an entity, and each edge represents how two vertices are associated.","title":"Directed property graph"},{"location":"nebula-design-concepts/#vertex-type-of-vertex-tag-and-the-corresponding-vertex-properties","text":"In Nebula Graph, the type of vertex is called tag . A vertex must have at least one type (tag) or multiple types (tag). Each tag has a corresponding set of properties called schema. Consider the above picture as example, there are two types of vertices: player and team . Vertex player's schema has three properties: id (vid), Name(string), and Age(int); vertex team's schema has two properties: id (vid) and Name(string). Like Mysql, Nebula Graph is a strong schema database. The property name and data type are determined before the data is written.","title":"Vertex, type of vertex (tag) and the corresponding vertex properties"},{"location":"nebula-design-concepts/#edge-edgetype-and-the-corresponding-edge-properties","text":"Edges in Nebula Graph always have a type, a start (src)and an end vertex (dst), and a direction. They can be self-referencing/looping but can never be dangling (missing a start or end node). Each edge has an edgetype, and each edgetype defines the properties of the edge. In the preceding example, there are two kinds of edges, one is like pointing from player to player, the property is likeness (double); the other is serve , pointing from team to serve, the properties are start_year(int) and end_year(int). It should be noted that there may be multiple edges of the same or different types at the same time between the start (src)and end vertex (dst).","title":"Edge, edgetype and the corresponding edge properties"},{"location":"nebula-design-concepts/#graph-partition","text":"Since the number of vertices in a super large-scale relational network can reach to dozen billions or trillions, and the number of edges can even be dozen trillions, the storage of both will exceed the capacity of a general server. Therefore, a method is needed to cut the graph elements and store them on different logical partitions. Nebula Graph conducts edge splitting to make partitions, and its default strategy is Hash. The number of partitions is static and cannot be changed.","title":"Graph partition"},{"location":"nebula-design-concepts/#data-model","text":"In Nebula Graph, each vertex is modeled as key-values, then stored to the corresponding partition after hashing according to its vertexID. An edge is modeled as two separate key-values in Nebula Graph, i.e. out-key and in-key, respectively. The out-key and the edge's corresponding starting point are stored in one partition, while the in-key and end point are stored in another one.","title":"Data model"},{"location":"nebula-design-concepts/#architecture","text":"Nebula Graph includes four modules: storage layer, metadata service, computation layer and client console.","title":"Architecture"},{"location":"nebula-design-concepts/#storage-layer","text":"The corresponding process of storage layer is nebula-storaged, and its core is the distributed Key-value Storage based on RAFT protocol. Currently it supports multiple storage engines like Rocksdb and HBase, etc. Raft protocol ensures data consistency by leader/follower mechanism. Based on that, Nebula Storage makes the following optimizations: Parallel Raft Partitions of same ID from multiple machines form a raft group. And the concurrent operations are implemented with multiple sets of Raft groups. Write Path & batch In Raft protocol, multi-machine synchronization depends on log ID orders, which lead to low throughput. Nebula achieves high throughput by batch and out-of-order submission. Copy learner based on synchronism When added to cluster, new machines will be tagged as learner and pull data from leader/follower synchronically. The learner will be tagged as follower and participate in Raft protocol when it catches up leader. Load-balance For machines with high stress, migrate the partition they serve to machines with low stress for better load balancing.","title":"Storage layer"},{"location":"nebula-design-concepts/#metadata-service","text":"The process corresponding to the Meta service is nebula-metad, and its main functions are: User management Nebula Graph's user system includes God user, Admin, User, and Guest, each is different in operating privileges. Cluster configuration management Support online and offline new servers. Graph space management Add, drop graph space, modify graph space configuration (Raft copies) Schema management Nebula Graph is a strong schema database. Types of Tag and Edge properties are recorded by Meta service. Supported types are: int, double, timestamp, list, etc. Multi-version management, supporting adding, modifying and deleting schema, and recording its version. TTL (time-to-live) management, supporting automatic data deletion and space reclamation. The Meta Service layer is state, and just like the Storage layer, it maintains state persistence through KV Store.","title":"Metadata service"},{"location":"nebula-design-concepts/#query-engine-query-language-ngql","text":"The process corresponding to the computation layer is nebula-graphd, which consists of computing vertices that are fully equal, stateless, and unrelated. There is no communication among the computing vertices. The main function of the Query Engine layer is to analysis the nGQL text sent by the client and generate an execution plan through lexical analysis (Lexer) and parsing (Parser). Then the execution plan will pass to the the execution engine. The execution engine obtains the schema of the graph vertices and edges through the Meta Service, then obtains the data of the vertices and edges through the storage engine layer. The main optimizations of the Query Engine layer are: Asynchronous and concurrent execution Since both IO and network are long-latency operations, asynchronous and concurrent operations are required. In addition, to avoid a single long query affecting subsequent queries, a separate resource pool is set for each query to guarantee quality of service (QoS). Push down Too much data passing back form storage layer to computation layer occupies too much bandwidth, to avoid that, operators such as conditional filtering (where) are sent to the storage layer along with the query filters. Execution plan optimization Execution plan optimization in relational database SQL has experienced a long period but research on the optimization of graph query language is relatively less. Nebula Graph also makes some exploration on the execution plan optimization of graph query, including executing plan cache and the concurrent execution of the context-free queries.","title":"Query Engine &amp; Query Language (nGQL)"},{"location":"nebula-design-concepts/#api-and-sdk","text":"Nebula Graph provides SDKs in C++, Java, and Golang. Nebula Graph uses RPC to communicate among servers, and the communication protocol is Facebook-Thrift. Users can also use Nebula Graph on Linux. Nebula Graph's web SDK is in progress and will be released soon.","title":"API and SDK"}]}