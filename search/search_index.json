{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the official Nebula Graph documentation. \u00b6 Nebula Graph is a distributed, scalable, lightning-fast graph database. It is the only solution in the world capable to host graphs with dozens of billions of vertices (nodes) and trillions of edges, while still provides millisecond latency. Nebula Graph's goal is to provide reading, writing, and computing with high concurrency, low latency for super large scale graphs. Nebula is an open source project and we are looking forward to working with the community to popularize and promote the graph database. Nebula Graph's primary features Symmetrically distributed Highly scalable Fault tolerant SQL-like query language How can I get Nebula \u00b6 Nebula Graph source code is available here on GitHub . The currently release is version R1910_alpha. You can also download Docker image to try it. More details on how to get Nebula image click Get Started . How can I contribute \u00b6 As the team behind Nebula Graph , we fully commit to the community and all-in to the open source project. All the core features are and will be implemented in the open source repository. We also encourage the community to involve the project. There are a few ways you can contribute: You can download and try Nebula Graph , and provide us feedbacks You can submit your feature requirements and bug reports You can help contribute the documentations. More details on how to contribute click Contribute to Nebula Graph Docs You can fix bugs or implement features. More details on how to build the project and submit the Pull Requests click Contribute to Nebula Graph Licensing \u00b6 Nebula Graph is under Apache 2.0 license, so you can freely download, modify, deploy the source code to meet your needs. You can also freely deploy Nebula Graph as a back-end service to support your SAAS deployment. In order to prevent cloud providers monetarizing from the project without contributing back, we added Common Clause 1.0 to the project. As mentioned above, we fully commit to the open source community. We would love to hear your thoughts on the licensing model and are willing to make it more suitable for the community. Contact \u00b6 Please use GitHub issue tracker for reporting bugs or feature requests. Join . Visit Nebula Graph home page for more features.","title":"Overview"},{"location":"#welcome-to-the-official-nebula-graph-documentation","text":"Nebula Graph is a distributed, scalable, lightning-fast graph database. It is the only solution in the world capable to host graphs with dozens of billions of vertices (nodes) and trillions of edges, while still provides millisecond latency. Nebula Graph's goal is to provide reading, writing, and computing with high concurrency, low latency for super large scale graphs. Nebula is an open source project and we are looking forward to working with the community to popularize and promote the graph database. Nebula Graph's primary features Symmetrically distributed Highly scalable Fault tolerant SQL-like query language","title":"Welcome to the official Nebula Graph documentation."},{"location":"#how-can-i-get-nebula","text":"Nebula Graph source code is available here on GitHub . The currently release is version R1910_alpha. You can also download Docker image to try it. More details on how to get Nebula image click Get Started .","title":"How can I get Nebula"},{"location":"#how-can-i-contribute","text":"As the team behind Nebula Graph , we fully commit to the community and all-in to the open source project. All the core features are and will be implemented in the open source repository. We also encourage the community to involve the project. There are a few ways you can contribute: You can download and try Nebula Graph , and provide us feedbacks You can submit your feature requirements and bug reports You can help contribute the documentations. More details on how to contribute click Contribute to Nebula Graph Docs You can fix bugs or implement features. More details on how to build the project and submit the Pull Requests click Contribute to Nebula Graph","title":"How can I contribute"},{"location":"#licensing","text":"Nebula Graph is under Apache 2.0 license, so you can freely download, modify, deploy the source code to meet your needs. You can also freely deploy Nebula Graph as a back-end service to support your SAAS deployment. In order to prevent cloud providers monetarizing from the project without contributing back, we added Common Clause 1.0 to the project. As mentioned above, we fully commit to the open source community. We would love to hear your thoughts on the licensing model and are willing to make it more suitable for the community.","title":"Licensing"},{"location":"#contact","text":"Please use GitHub issue tracker for reporting bugs or feature requests. Join . Visit Nebula Graph home page for more features.","title":"Contact"},{"location":"contribute-to-documentation/","text":"Contribute to documentation \u00b6 Contributing to the Nebula documentation can be a rewarding experience. We welcome your participation to help make the documentation better! How to contribute to the docs \u00b6 There are many ways to contribute: Edit, rate, or file an issue or question directly on the site by using the pencil mark available on the right-side on every page. File a documentation issue on GitHub . Fork the documentation, make changes or add new content on your local branch, and submit a pull request (PR) to the master branch for the docs.","title":"Contribute to docs"},{"location":"contribute-to-documentation/#contribute-to-documentation","text":"Contributing to the Nebula documentation can be a rewarding experience. We welcome your participation to help make the documentation better!","title":"Contribute to documentation"},{"location":"contribute-to-documentation/#how-to-contribute-to-the-docs","text":"There are many ways to contribute: Edit, rate, or file an issue or question directly on the site by using the pencil mark available on the right-side on every page. File a documentation issue on GitHub . Fork the documentation, make changes or add new content on your local branch, and submit a pull request (PR) to the master branch for the docs.","title":"How to contribute to the docs"},{"location":"cpp-coding-style/","text":"Please Refer to Google C++ Style Guide .","title":"Cpp coding style"},{"location":"developer-documentation-style-guide/","text":"Key Point: Use this guide as a style reference for our developer documentation. Goals \u00b6 The guide can help you avoid making decisions about the same issue over and over, can provide editorial assistance on structuring and writing your documentation, and can help you keep your documentation consistent with our other documentation. Non-goals \u00b6 This guide isn't intended to provide an industry documentation standard, nor to compete with other well-known style guides. It's a description of our house style, not a statement that our decisions are objectively correct. This guide is a living document; it changes over time, and when it changes, we generally don't change previously published documentation to match. We strive for consistency to the extent feasible, but at any given time there are certain to be parts of our documentation that don't match this style guide. When in doubt, follow this guide rather than imitating existing documents. Breaking the \"rules\" \u00b6 In most contexts, Nebula has no ability nor desire to enforce these guidelines if they're not appropriate to the context. But we hope that you'll join us in striving for high-quality documentation. Like most style guides, our style guide aims to improve our documentation, especially by improving consistency; therefore, there may be contexts where it makes sense to diverge from our guidelines in order to make your documentation better. Style and authorial tone \u00b6 Aim, in your documents, for a voice and tone that's conversational, friendly, and respectful without being overly colloquial or frivolous; a voice that's casual and natural and approachable, not pedantic or pushy. Try to sound like a knowledgeable friend who understands what the developer wants to do. Don't try to write exactly the way you speak; you probably speak more colloquially and verbosely than you should write, at least for developer documentation. But aim for a conversational tone rather than a formal one. Some techniques and approaches to consider \u00b6 If you're having trouble expressing something, step back and ask yourself, \"What am I trying to say?\" Often, the answer you give yourself reveals what you should be saying in the document. If you're uncertain about your phrasing or tone, ask a colleague to take a look. Try reading parts of your document out loud, or at least mouthing the words. Does it sound natural? Not every sentence has to sound natural when spoken; these are written documents. But if you come across a sentence that's awkward or confusing when spoken, consider whether you can make it more conversational. Use transitions between sentences. Phrases like \"Though\" or \"This way\" can make paragraphs less stilted. (Then again, sometimes transitions like \"However\" or \"Nonetheless\" can make paragraphs more stilted.) Even if you're having trouble hitting the right tone, make sure you're communicating useful information in a clear and direct way; that's the most important part. Tense \u00b6 In general, use present tense rather than future tense; in particular, try to avoid using will where possible. The fact that the reader will be writing and running code in the future isn't a good reason to use future tense. Stick with present tense where. Also avoid the hypothetical future would . Links \u00b6 When you're writing link text, use a phrase that describes what the reader will see after following the link. That can take either of two forms: - The exact title of the linked-to page, capitalized the same way the title is capitalized. - A description of the linked-to page, capitalized like ordinary text instead of like a title. A couple of specific things to not do in link text: - Don't use the phrase \"click here.\" (It's bad for accessibility and bad for scannability.) - Similarly, don't use phrases like \"this document.\" (It's easy to read \"this\" as meaning \"the one you're reading now\" rather than \"the one I'm pointing to.\") - Don't use a URL as link text. Instead, use the page title or a description of the page. Punctuation with links \u00b6 If you have punctuation immediately before or after a link, put the punctuation outside of the link tags where possible. In particular, put quotation marks outside of link tags. Accessible content \u00b6 General dos and don'ts \u00b6 Ensure that readers can reach all parts of the document (including tabs, form-submission buttons, and interactive elements) using only a keyboard, without a mouse or trackpad. Don't use color, size, location, or other visual cues as the primary way of communicating information. If you're using color, icon, or outline thickness to convey state, then also provide a secondary cue, such as a change in the text label. Refer to buttons and other elements by their label (or aria-label , if they\u2019re visual elements), not by location or shape. Avoid unnecessary font formatting. (Screen readers explicitly describe text modifications.) If you're documenting a product that includes specialized accessibility features, then explicitly document those features. For example, the gcloud command-line tool includes togglable accessibility features such as percentage progress bars and ASCII box rendering. Images \u00b6 For every image, provide alt text that adequately summarizes the intent of each image. Don't present new information in images; always provide an equivalent text explanation with the image. Use SVG files or crushed PNG images. Provide high-resolution images when practical. Tables \u00b6 If your tables include both row and column headings, then mark heading cells with the scope attribute. If your tables have more than one row containing column headings, then use the headers attribute. Forms \u00b6 Label every input field, using a <label> element. Place labels outside of fields. When you're creating an error message for form validation, clearly state what went wrong and how to fix it. For example: \"Name is a required field.\" Videos \u00b6 Provide captions. Ensure that captions can be translated into major languages. Language and grammar \u00b6 Use second person: \"you\" rather than \"we.\" Use active voice; make clear who's performing the action. Use standard American spelling and punctuation. Put conditional clauses before instructions, not after. For usage and spelling of specific words, see the word list. Formatting, punctuation, and organization \u00b6 Use sentence case for document titles and section headings. Use numbered lists for sequences. Use bulleted lists for most other lists. Use description lists for pairs of related pieces of data. Use serial commas . Put code-related text in code font . Put UI elements in bold . Use unambiguous date formatting .","title":"Developer documentation style guide"},{"location":"developer-documentation-style-guide/#goals","text":"The guide can help you avoid making decisions about the same issue over and over, can provide editorial assistance on structuring and writing your documentation, and can help you keep your documentation consistent with our other documentation.","title":"Goals"},{"location":"developer-documentation-style-guide/#non-goals","text":"This guide isn't intended to provide an industry documentation standard, nor to compete with other well-known style guides. It's a description of our house style, not a statement that our decisions are objectively correct. This guide is a living document; it changes over time, and when it changes, we generally don't change previously published documentation to match. We strive for consistency to the extent feasible, but at any given time there are certain to be parts of our documentation that don't match this style guide. When in doubt, follow this guide rather than imitating existing documents.","title":"Non-goals"},{"location":"developer-documentation-style-guide/#breaking-the-rules","text":"In most contexts, Nebula has no ability nor desire to enforce these guidelines if they're not appropriate to the context. But we hope that you'll join us in striving for high-quality documentation. Like most style guides, our style guide aims to improve our documentation, especially by improving consistency; therefore, there may be contexts where it makes sense to diverge from our guidelines in order to make your documentation better.","title":"Breaking the \"rules\""},{"location":"developer-documentation-style-guide/#style-and-authorial-tone","text":"Aim, in your documents, for a voice and tone that's conversational, friendly, and respectful without being overly colloquial or frivolous; a voice that's casual and natural and approachable, not pedantic or pushy. Try to sound like a knowledgeable friend who understands what the developer wants to do. Don't try to write exactly the way you speak; you probably speak more colloquially and verbosely than you should write, at least for developer documentation. But aim for a conversational tone rather than a formal one.","title":"Style and authorial tone"},{"location":"developer-documentation-style-guide/#some-techniques-and-approaches-to-consider","text":"If you're having trouble expressing something, step back and ask yourself, \"What am I trying to say?\" Often, the answer you give yourself reveals what you should be saying in the document. If you're uncertain about your phrasing or tone, ask a colleague to take a look. Try reading parts of your document out loud, or at least mouthing the words. Does it sound natural? Not every sentence has to sound natural when spoken; these are written documents. But if you come across a sentence that's awkward or confusing when spoken, consider whether you can make it more conversational. Use transitions between sentences. Phrases like \"Though\" or \"This way\" can make paragraphs less stilted. (Then again, sometimes transitions like \"However\" or \"Nonetheless\" can make paragraphs more stilted.) Even if you're having trouble hitting the right tone, make sure you're communicating useful information in a clear and direct way; that's the most important part.","title":"Some techniques and approaches to consider"},{"location":"developer-documentation-style-guide/#tense","text":"In general, use present tense rather than future tense; in particular, try to avoid using will where possible. The fact that the reader will be writing and running code in the future isn't a good reason to use future tense. Stick with present tense where. Also avoid the hypothetical future would .","title":"Tense"},{"location":"developer-documentation-style-guide/#links","text":"When you're writing link text, use a phrase that describes what the reader will see after following the link. That can take either of two forms: - The exact title of the linked-to page, capitalized the same way the title is capitalized. - A description of the linked-to page, capitalized like ordinary text instead of like a title. A couple of specific things to not do in link text: - Don't use the phrase \"click here.\" (It's bad for accessibility and bad for scannability.) - Similarly, don't use phrases like \"this document.\" (It's easy to read \"this\" as meaning \"the one you're reading now\" rather than \"the one I'm pointing to.\") - Don't use a URL as link text. Instead, use the page title or a description of the page.","title":"Links"},{"location":"developer-documentation-style-guide/#punctuation-with-links","text":"If you have punctuation immediately before or after a link, put the punctuation outside of the link tags where possible. In particular, put quotation marks outside of link tags.","title":"Punctuation with links"},{"location":"developer-documentation-style-guide/#accessible-content","text":"","title":"Accessible content"},{"location":"developer-documentation-style-guide/#general-dos-and-donts","text":"Ensure that readers can reach all parts of the document (including tabs, form-submission buttons, and interactive elements) using only a keyboard, without a mouse or trackpad. Don't use color, size, location, or other visual cues as the primary way of communicating information. If you're using color, icon, or outline thickness to convey state, then also provide a secondary cue, such as a change in the text label. Refer to buttons and other elements by their label (or aria-label , if they\u2019re visual elements), not by location or shape. Avoid unnecessary font formatting. (Screen readers explicitly describe text modifications.) If you're documenting a product that includes specialized accessibility features, then explicitly document those features. For example, the gcloud command-line tool includes togglable accessibility features such as percentage progress bars and ASCII box rendering.","title":"General dos and don'ts"},{"location":"developer-documentation-style-guide/#images","text":"For every image, provide alt text that adequately summarizes the intent of each image. Don't present new information in images; always provide an equivalent text explanation with the image. Use SVG files or crushed PNG images. Provide high-resolution images when practical.","title":"Images"},{"location":"developer-documentation-style-guide/#tables","text":"If your tables include both row and column headings, then mark heading cells with the scope attribute. If your tables have more than one row containing column headings, then use the headers attribute.","title":"Tables"},{"location":"developer-documentation-style-guide/#forms","text":"Label every input field, using a <label> element. Place labels outside of fields. When you're creating an error message for form validation, clearly state what went wrong and how to fix it. For example: \"Name is a required field.\"","title":"Forms"},{"location":"developer-documentation-style-guide/#videos","text":"Provide captions. Ensure that captions can be translated into major languages.","title":"Videos"},{"location":"developer-documentation-style-guide/#language-and-grammar","text":"Use second person: \"you\" rather than \"we.\" Use active voice; make clear who's performing the action. Use standard American spelling and punctuation. Put conditional clauses before instructions, not after. For usage and spelling of specific words, see the word list.","title":"Language and grammar"},{"location":"developer-documentation-style-guide/#formatting-punctuation-and-organization","text":"Use sentence case for document titles and section headings. Use numbered lists for sequences. Use bulleted lists for most other lists. Use description lists for pairs of related pieces of data. Use serial commas . Put code-related text in code font . Put UI elements in bold . Use unambiguous date formatting .","title":"Formatting, punctuation, and organization"},{"location":"get-started/","text":"This tutorial provides a quick introduction to use Nebula Graph . Install Nebula Graph \u00b6 From Docker \u00b6 The easiest way to startup nebula is using docker . First of all, you should make sure that docker has been installed on your machine. Open a terminal and run the following command : > docker --version Docker version 18.09.2, build 6247962 If docker is not found, please see here for more information to install docker. After that, using > docker pull vesoft/nebula-graph:latest ac9208207ada: Pulling fs layer cdcb67189ff7: Pulling fs layer 80407c3cb6b4: Pulling fs layer latest: Pulling from vesoft/nebula-graph ac9208207ada: Pull complete cdcb67189ff7: Pull complete 80407c3cb6b4: Pull complete Digest: sha256:72a73c801685595776779291969b57ab758f53ebd9bda8bab56421e50bfee161 Status: Downloaded newer image for vesoft/nebula-graph:latest to get nebula docker images. Then type command docker images to check the image status. > docker images REPOSITORY TAG IMAGE ID CREATED SIZE vesoft/nebula-graph latest 1afd60e223ca 4 weeks ago 401MB Startup Nebula Graph When nebula image is ready, run > docker run -it vesoft/nebula-graph:latest /bin/bash to start and login to the docker container. After login, you're in the root directory and you should use cd ~/nebula-graph/ to switch to the nebula home directory. Run > ./start-all.sh Starting MetaService StorageService and GraphService ... to start meta service, storage service and graph service. Run > ps -ef | grep nebula to display the services' running status. Please make sure the services are working. To connect to the graph server, run > ./start-console.sh Welcome to Nebula Graph (Version 0.1) nebula> If you have any questions or concerns about the deployment procedures, please do not hesitate to open an issue on GitHub . From Source(Linux) \u00b6 Prerequisite Tools Nebula Graph is written in C++14, so it requires a complier supporting C++14 features. 3rd-party Libraries autoconf automake libtool cmake bison unzip boost gperf krb5 openssl libunwind ncurses readline It is recommended to install g++ 5 or higher Linux system, such as Fedora 29. Currently, we are using git-lfs to store the 3rd-party libraries so make sure git-lfs have been installed before fetching the source code. Fetch from GitHub > git clone https://github.com/vesoft-inc/nebula.git Compiling > cmake ./ The default installation is in /usr/local path. To specify the installation path, use: > cmake -DCMAKE_INSTALL_PREFIX=$your_nebula_install_dir to replace the $your_nebula_install_dir here Then run the following command: > make && make install Running Configure nebula-metad.conf In your Nebula installation directory, run > cp etc/nebula-metad.conf.default etc/nebula-metad.conf Modify configurations in nebula-metad.conf: local_ip port ws_http_port metaservice HTTP ws_h2_port metaservice HTTP2 Configure nebula-storaged.conf > cp etc/nebula-storaged.conf.default etc/nebula-storaged.conf Modify configurations in nebula-storaged.conf: local_ip port ws_http_port storageservice HTTP ws_h2_port storageservice HTTP2 Configure nebula-graphd.conf > cp etc/nebula-graphd.conf.default etc/nebula-graphd.conf Modify configurations in nebula-graphd.conf: local_ip port ws_http_port graphservice HTTP ws_h2_port graphservice HTTP2 Start service > scripts/nebula.service start all Make sure all the services are working > scripts/nebula.service status all Connect to Nebula > bin/nebula -u=user -p=password -u is to set user name, user is the default Nebula user account -p is to set password, password is the default password for account user Add host to make console connect to the Nebula service: > ADD HOSTS $storage_ip:$storage_port Replace the $storage_ip and $storage_port here according to the local_ip and port in nebula-storaged.conf Then you\u2019re now ready to start using Nebula Graph. Build Your Own Graph \u00b6 This section describes how to build a graph and run queries. The example is built on the graph below: There are three kinds of tags ( course , building and team ) and two edge types ( select and like ). The graph schema is: { \"tags\" :{ \"course\" :[ \"name: string\" , \"credits: integer\" ], \"building\" :[ \"name: string\" ], \"student\" :[ \"name: string\" , \"age: integer\" , \"gender: string\" ] }, \"edges\" :{ \"select\" :[ \"grade: integer\" ], \"like\" :[ \"likeness: double\" ] } } Create a Graph Space \u00b6 SPACE is a region that provides physically isolation of graphs in Nebula. First we need to create a space and use it before other operations. To list all existing spaces: nebula> SHOW SPACES; To create a new space named myspace_test2 : nebula> CREATE SPACE myspace_test2(partition_num=1, replica_factor=1); -- Use this space nebula> USE myspace_test2; replica_factor specifies the number of replicas in the cluster. partition_num specifies the number of partitions in one replica. Define Graph Schema \u00b6 The CREATE TAG statement defines a tag, with a type name and an attribute list. nebula> CREATE TAG course(name string, credits int); nebula> CREATE TAG building(name string); nebula> CREATE TAG student(name string, age int, gender string); The CREATE EDGE statement defines an edge type. nebula> CREATE EDGE like(likeness double); nebula> CREATE EDGE select(grade int); To list the tags and edge types that we just created\uff1a -- Show tag list nebula> SHOW TAGS; -- Show edge type list nebula> SHOW EDGES; To show the attributes of a tag or an edge type: -- Show attributes of a tag nebula> DESCRIBE TAG student; -- Show attributes of an edge type nebula> DESCRIBE EDGE like; Insert Data \u00b6 Insert the vertices and edges based on the graph above. -- Insert vertices nebula> INSERT VERTEX student(name, age, gender) VALUES 200:(\"Monica\", 16, \"female\"); nebula> INSERT VERTEX student(name, age, gender) VALUES 201:(\"Mike\", 18, \"male\"); nebula> INSERT VERTEX student(name, age, gender) VALUES 202:(\"Jane\", 17, \"female\"); nebula> INSERT VERTEX course(name, credits),building(name) VALUES 101:(\"Math\", 3, \"No5\"); nebula> INSERT VERTEX course(name, credits),building(name) VALUES 102:(\"English\", 6, \"No11\"); -- Insert edges nebula> INSERT EDGE select(grade) VALUES 200 -> 101:(5); nebula> INSERT EDGE select(grade) VALUES 200 -> 102:(3); nebula> INSERT EDGE select(grade) VALUES 201 -> 102:(3); nebula> INSERT EDGE select(grade) VALUES 202 -> 102:(3); nebula> INSERT EDGE like(likeness) VALUES 200 -> 201:(92.5); nebula> INSERT EDGE like(likeness) VALUES 201 -> 200:(85.6); nebula> INSERT EDGE like(likeness) VALUES 201 -> 202:(93.2); Sample Queries \u00b6 Q1. Find the vertexes that 201 likes: nebula> GO FROM 201 OVER like; ======= | id | ======= | 200 | ------- | 202 | ------- Q2. Find the vertexes that 201 likes, whose age are greater than 17. Return their name, age and gender, and alias the columns as Friend, Age and Gender, respectively. nebula> GO FROM 201 OVER like WHERE $$.student.age >= 17 YIELD $$.student.name AS Friend, $$.student.age AS Age, $$.student.gender AS Gender; ========================= | Friend | Age | Gender | ========================= | Jane | 17 | female | ------------------------- YIELD specifies what values or results you might want to return from query. $^ represents the source vertex. $$ indicates the target vertex. Q3. Find the courses that the vertices liked by 201 select and their grade. -- By pipe nebula> GO FROM 201 OVER like | GO FROM $-.id OVER select YIELD $^.student.name AS Student, $$.course.name AS Course, select.grade AS Grade; ============================= | Student | Course | Grade | ============================= | Monica | Math | 5 | ----------------------------- | Monica | English | 3 | ----------------------------- | Jane | English | 3 | ----------------------------- -- By temporary variable nebula> $a=GO FROM 201 OVER like; GO FROM $a.id OVER select YIELD $^.student.name AS Student, $$.course.name AS Course, select.grade AS Grade; ============================= | Student | Course | Grade | ============================= | Monica | Math | 5 | ----------------------------- | Monica | English | 3 | ----------------------------- | Jane | English | 3 | ----------------------------- | denotes a pipe. The output of the formal query acts as input to the next one like a pipeline. $- refers to the input stream. The second approach adopts a user-defined variable $a . The scope of this variable is within the compound statement. For more details about Query Language, check nGQL Query Language .","title":"Quickstart"},{"location":"get-started/#install-nebula-graph","text":"","title":"Install Nebula Graph"},{"location":"get-started/#from-docker","text":"The easiest way to startup nebula is using docker . First of all, you should make sure that docker has been installed on your machine. Open a terminal and run the following command : > docker --version Docker version 18.09.2, build 6247962 If docker is not found, please see here for more information to install docker. After that, using > docker pull vesoft/nebula-graph:latest ac9208207ada: Pulling fs layer cdcb67189ff7: Pulling fs layer 80407c3cb6b4: Pulling fs layer latest: Pulling from vesoft/nebula-graph ac9208207ada: Pull complete cdcb67189ff7: Pull complete 80407c3cb6b4: Pull complete Digest: sha256:72a73c801685595776779291969b57ab758f53ebd9bda8bab56421e50bfee161 Status: Downloaded newer image for vesoft/nebula-graph:latest to get nebula docker images. Then type command docker images to check the image status. > docker images REPOSITORY TAG IMAGE ID CREATED SIZE vesoft/nebula-graph latest 1afd60e223ca 4 weeks ago 401MB Startup Nebula Graph When nebula image is ready, run > docker run -it vesoft/nebula-graph:latest /bin/bash to start and login to the docker container. After login, you're in the root directory and you should use cd ~/nebula-graph/ to switch to the nebula home directory. Run > ./start-all.sh Starting MetaService StorageService and GraphService ... to start meta service, storage service and graph service. Run > ps -ef | grep nebula to display the services' running status. Please make sure the services are working. To connect to the graph server, run > ./start-console.sh Welcome to Nebula Graph (Version 0.1) nebula> If you have any questions or concerns about the deployment procedures, please do not hesitate to open an issue on GitHub .","title":"From Docker"},{"location":"get-started/#from-sourcelinux","text":"Prerequisite Tools Nebula Graph is written in C++14, so it requires a complier supporting C++14 features. 3rd-party Libraries autoconf automake libtool cmake bison unzip boost gperf krb5 openssl libunwind ncurses readline It is recommended to install g++ 5 or higher Linux system, such as Fedora 29. Currently, we are using git-lfs to store the 3rd-party libraries so make sure git-lfs have been installed before fetching the source code. Fetch from GitHub > git clone https://github.com/vesoft-inc/nebula.git Compiling > cmake ./ The default installation is in /usr/local path. To specify the installation path, use: > cmake -DCMAKE_INSTALL_PREFIX=$your_nebula_install_dir to replace the $your_nebula_install_dir here Then run the following command: > make && make install Running Configure nebula-metad.conf In your Nebula installation directory, run > cp etc/nebula-metad.conf.default etc/nebula-metad.conf Modify configurations in nebula-metad.conf: local_ip port ws_http_port metaservice HTTP ws_h2_port metaservice HTTP2 Configure nebula-storaged.conf > cp etc/nebula-storaged.conf.default etc/nebula-storaged.conf Modify configurations in nebula-storaged.conf: local_ip port ws_http_port storageservice HTTP ws_h2_port storageservice HTTP2 Configure nebula-graphd.conf > cp etc/nebula-graphd.conf.default etc/nebula-graphd.conf Modify configurations in nebula-graphd.conf: local_ip port ws_http_port graphservice HTTP ws_h2_port graphservice HTTP2 Start service > scripts/nebula.service start all Make sure all the services are working > scripts/nebula.service status all Connect to Nebula > bin/nebula -u=user -p=password -u is to set user name, user is the default Nebula user account -p is to set password, password is the default password for account user Add host to make console connect to the Nebula service: > ADD HOSTS $storage_ip:$storage_port Replace the $storage_ip and $storage_port here according to the local_ip and port in nebula-storaged.conf Then you\u2019re now ready to start using Nebula Graph.","title":"From Source(Linux)"},{"location":"get-started/#build-your-own-graph","text":"This section describes how to build a graph and run queries. The example is built on the graph below: There are three kinds of tags ( course , building and team ) and two edge types ( select and like ). The graph schema is: { \"tags\" :{ \"course\" :[ \"name: string\" , \"credits: integer\" ], \"building\" :[ \"name: string\" ], \"student\" :[ \"name: string\" , \"age: integer\" , \"gender: string\" ] }, \"edges\" :{ \"select\" :[ \"grade: integer\" ], \"like\" :[ \"likeness: double\" ] } }","title":"Build Your Own Graph"},{"location":"get-started/#create-a-graph-space","text":"SPACE is a region that provides physically isolation of graphs in Nebula. First we need to create a space and use it before other operations. To list all existing spaces: nebula> SHOW SPACES; To create a new space named myspace_test2 : nebula> CREATE SPACE myspace_test2(partition_num=1, replica_factor=1); -- Use this space nebula> USE myspace_test2; replica_factor specifies the number of replicas in the cluster. partition_num specifies the number of partitions in one replica.","title":"Create a Graph Space"},{"location":"get-started/#define-graph-schema","text":"The CREATE TAG statement defines a tag, with a type name and an attribute list. nebula> CREATE TAG course(name string, credits int); nebula> CREATE TAG building(name string); nebula> CREATE TAG student(name string, age int, gender string); The CREATE EDGE statement defines an edge type. nebula> CREATE EDGE like(likeness double); nebula> CREATE EDGE select(grade int); To list the tags and edge types that we just created\uff1a -- Show tag list nebula> SHOW TAGS; -- Show edge type list nebula> SHOW EDGES; To show the attributes of a tag or an edge type: -- Show attributes of a tag nebula> DESCRIBE TAG student; -- Show attributes of an edge type nebula> DESCRIBE EDGE like;","title":"Define Graph Schema"},{"location":"get-started/#insert-data","text":"Insert the vertices and edges based on the graph above. -- Insert vertices nebula> INSERT VERTEX student(name, age, gender) VALUES 200:(\"Monica\", 16, \"female\"); nebula> INSERT VERTEX student(name, age, gender) VALUES 201:(\"Mike\", 18, \"male\"); nebula> INSERT VERTEX student(name, age, gender) VALUES 202:(\"Jane\", 17, \"female\"); nebula> INSERT VERTEX course(name, credits),building(name) VALUES 101:(\"Math\", 3, \"No5\"); nebula> INSERT VERTEX course(name, credits),building(name) VALUES 102:(\"English\", 6, \"No11\"); -- Insert edges nebula> INSERT EDGE select(grade) VALUES 200 -> 101:(5); nebula> INSERT EDGE select(grade) VALUES 200 -> 102:(3); nebula> INSERT EDGE select(grade) VALUES 201 -> 102:(3); nebula> INSERT EDGE select(grade) VALUES 202 -> 102:(3); nebula> INSERT EDGE like(likeness) VALUES 200 -> 201:(92.5); nebula> INSERT EDGE like(likeness) VALUES 201 -> 200:(85.6); nebula> INSERT EDGE like(likeness) VALUES 201 -> 202:(93.2);","title":"Insert Data"},{"location":"get-started/#sample-queries","text":"Q1. Find the vertexes that 201 likes: nebula> GO FROM 201 OVER like; ======= | id | ======= | 200 | ------- | 202 | ------- Q2. Find the vertexes that 201 likes, whose age are greater than 17. Return their name, age and gender, and alias the columns as Friend, Age and Gender, respectively. nebula> GO FROM 201 OVER like WHERE $$.student.age >= 17 YIELD $$.student.name AS Friend, $$.student.age AS Age, $$.student.gender AS Gender; ========================= | Friend | Age | Gender | ========================= | Jane | 17 | female | ------------------------- YIELD specifies what values or results you might want to return from query. $^ represents the source vertex. $$ indicates the target vertex. Q3. Find the courses that the vertices liked by 201 select and their grade. -- By pipe nebula> GO FROM 201 OVER like | GO FROM $-.id OVER select YIELD $^.student.name AS Student, $$.course.name AS Course, select.grade AS Grade; ============================= | Student | Course | Grade | ============================= | Monica | Math | 5 | ----------------------------- | Monica | English | 3 | ----------------------------- | Jane | English | 3 | ----------------------------- -- By temporary variable nebula> $a=GO FROM 201 OVER like; GO FROM $a.id OVER select YIELD $^.student.name AS Student, $$.course.name AS Course, select.grade AS Grade; ============================= | Student | Course | Grade | ============================= | Monica | Math | 5 | ----------------------------- | Monica | English | 3 | ----------------------------- | Jane | English | 3 | ----------------------------- | denotes a pipe. The output of the formal query acts as input to the next one like a pipeline. $- refers to the input stream. The second approach adopts a user-defined variable $a . The scope of this variable is within the compound statement. For more details about Query Language, check nGQL Query Language .","title":"Sample Queries"},{"location":"how-to-build/","text":"General \u00b6 Compiler \u00b6 The project Nebula is developed using C++14, so it requires a compiler supporting C++14 features. 3rd-party Libraries \u00b6 The project itself includes the source code of several 3rd-party libraries, which usually does not exist in the OS's public application repositories. In addition to the included libraries, Nebula requires these 3rd-party utilities and libraries to be installed on the system autoconf automake libtool cmake bison unzip boost gperf krb5 openssl libunwind ncurses readline Currently, we using git-lfs to manage the 3rd-party libraries. So make sure git-lfs have been installed before building the source code. Please see INSTALLING.md for more details.","title":"How to build"},{"location":"how-to-build/#general","text":"","title":"General"},{"location":"how-to-build/#compiler","text":"The project Nebula is developed using C++14, so it requires a compiler supporting C++14 features.","title":"Compiler"},{"location":"how-to-build/#3rd-party-libraries","text":"The project itself includes the source code of several 3rd-party libraries, which usually does not exist in the OS's public application repositories. In addition to the included libraries, Nebula requires these 3rd-party utilities and libraries to be installed on the system autoconf automake libtool cmake bison unzip boost gperf krb5 openssl libunwind ncurses readline Currently, we using git-lfs to manage the 3rd-party libraries. So make sure git-lfs have been installed before building the source code. Please see INSTALLING.md for more details.","title":"3rd-party Libraries"},{"location":"how-to-contribute/","text":"Step 1: Fork in the cloud \u00b6 Visit https://github.com/vesoft-inc/nebula Click Fork button (top right) to establish a cloud-based fork. Step 2: Clone fork to local storage \u00b6 Define a local working directory: # Define your working directory working_dir = $HOME /Workspace Set user to match your github profile name: user ={ your github profile name } Create your clone: mkdir -p $working_dir cd $working_dir git clone https://github.com/ $user /nebula.git # the following is recommended # or: git clone git@github.com:$user/nebula.git cd $working_dir /nebula git remote add upstream https://github.com/vesoft-inc/nebula.git # or: git remote add upstream git@github.com:vesoft-inc/nebula.git # Never push to upstream master since you do not have write access. git remote set-url --push upstream no_push # Confirm that your remotes make sense: # It should look like: # origin git@github.com:$(user)/nebula.git (fetch) # origin git@github.com:$(user)/nebula.git (push) # upstream https://github.com/vesoft-inc/nebula (fetch) # upstream no_push (push) git remote -v Define a pre-commit hook \u00b6 Please link the Nebula Graph pre-commit hook into your .git directory. This hook checks your commits for formatting, building, doc generation, etc. cd $working_dir /nebula/.git/hooks ln -s ../../cpplint/bin/pre-commit.sh . Sometime, pre-commit hook can not be executable. In such case, you have to make it executable manually. cd $working_dir /nebula/.git/hooks chmod +x pre-commit Step 3: Branch \u00b6 Get your local master up to date: cd $working_dir /nebula git fetch upstream git checkout master git rebase upstream/master Branch from master: git checkout -b myfeature NOTE : Because your PR often consists of several commits, which might be squashed while being merged into upstream, we strongly suggest you open a separate topic branch to make your changes on. After merged, this topic branch could be just abandoned, thus you could synchronize your master branch with upstream easily with a rebase like above. Otherwise, if you commit your changes directly into master, maybe you must use a hard reset on the master branch, like: git fetch upstream git checkout master git reset --hard upstream/master git push --force origin master Step 4: Develop \u00b6 Edit the code \u00b6 You can now edit the code on the myfeature branch. Please follow the coding style guidance here . Run stand-alone mode \u00b6 If you want to reproduce and investigate an issue, you may need to run Nebula Graph in stand-alone mode. # Build the binary. make server # Run in stand-alone mode. nebula-graphd Then you can connect the Nebula Graph console to your local server nebula Run Test \u00b6 # Run unit test to make sure all test passed. Step 5: Keep your branch in sync \u00b6 # While on your myfeature branch. git fetch upstream git rebase upstream/master Step 6: Commit \u00b6 Commit your changes. git commit Likely you'll go back and edit/build/test some more than commit --amend in a few cycles. Step 7: Push \u00b6 When ready to review (or just to establish an offsite backup or your work), push your branch to your fork on github.com : git push -f origin myfeature Step 8: Create a pull request \u00b6 Visit your fork at https://github.com/$user/nebula (replace $user obviously). Click the Compare & pull request button next to your myfeature branch. Step 9: Get a code review \u00b6 Once your pull request has been opened, it will be assigned to at least one reviewers. Those reviewers will do a thorough code review, looking for correctness, bugs, opportunities for improvement, documentation and comments, and style. Commit changes made in response to review comments to the same branch on your fork. Very small PRs are easy to review. Very large PRs are very difficult to review.","title":"Contribute to Nebula"},{"location":"how-to-contribute/#step-1-fork-in-the-cloud","text":"Visit https://github.com/vesoft-inc/nebula Click Fork button (top right) to establish a cloud-based fork.","title":"Step 1: Fork in the cloud"},{"location":"how-to-contribute/#step-2-clone-fork-to-local-storage","text":"Define a local working directory: # Define your working directory working_dir = $HOME /Workspace Set user to match your github profile name: user ={ your github profile name } Create your clone: mkdir -p $working_dir cd $working_dir git clone https://github.com/ $user /nebula.git # the following is recommended # or: git clone git@github.com:$user/nebula.git cd $working_dir /nebula git remote add upstream https://github.com/vesoft-inc/nebula.git # or: git remote add upstream git@github.com:vesoft-inc/nebula.git # Never push to upstream master since you do not have write access. git remote set-url --push upstream no_push # Confirm that your remotes make sense: # It should look like: # origin git@github.com:$(user)/nebula.git (fetch) # origin git@github.com:$(user)/nebula.git (push) # upstream https://github.com/vesoft-inc/nebula (fetch) # upstream no_push (push) git remote -v","title":"Step 2: Clone fork to local storage"},{"location":"how-to-contribute/#define-a-pre-commit-hook","text":"Please link the Nebula Graph pre-commit hook into your .git directory. This hook checks your commits for formatting, building, doc generation, etc. cd $working_dir /nebula/.git/hooks ln -s ../../cpplint/bin/pre-commit.sh . Sometime, pre-commit hook can not be executable. In such case, you have to make it executable manually. cd $working_dir /nebula/.git/hooks chmod +x pre-commit","title":"Define a pre-commit hook"},{"location":"how-to-contribute/#step-3-branch","text":"Get your local master up to date: cd $working_dir /nebula git fetch upstream git checkout master git rebase upstream/master Branch from master: git checkout -b myfeature NOTE : Because your PR often consists of several commits, which might be squashed while being merged into upstream, we strongly suggest you open a separate topic branch to make your changes on. After merged, this topic branch could be just abandoned, thus you could synchronize your master branch with upstream easily with a rebase like above. Otherwise, if you commit your changes directly into master, maybe you must use a hard reset on the master branch, like: git fetch upstream git checkout master git reset --hard upstream/master git push --force origin master","title":"Step 3: Branch"},{"location":"how-to-contribute/#step-4-develop","text":"","title":"Step 4: Develop"},{"location":"how-to-contribute/#edit-the-code","text":"You can now edit the code on the myfeature branch. Please follow the coding style guidance here .","title":"Edit the code"},{"location":"how-to-contribute/#run-stand-alone-mode","text":"If you want to reproduce and investigate an issue, you may need to run Nebula Graph in stand-alone mode. # Build the binary. make server # Run in stand-alone mode. nebula-graphd Then you can connect the Nebula Graph console to your local server nebula","title":"Run stand-alone mode"},{"location":"how-to-contribute/#run-test","text":"# Run unit test to make sure all test passed.","title":"Run Test"},{"location":"how-to-contribute/#step-5-keep-your-branch-in-sync","text":"# While on your myfeature branch. git fetch upstream git rebase upstream/master","title":"Step 5: Keep your branch in sync"},{"location":"how-to-contribute/#step-6-commit","text":"Commit your changes. git commit Likely you'll go back and edit/build/test some more than commit --amend in a few cycles.","title":"Step 6: Commit"},{"location":"how-to-contribute/#step-7-push","text":"When ready to review (or just to establish an offsite backup or your work), push your branch to your fork on github.com : git push -f origin myfeature","title":"Step 7: Push"},{"location":"how-to-contribute/#step-8-create-a-pull-request","text":"Visit your fork at https://github.com/$user/nebula (replace $user obviously). Click the Compare & pull request button next to your myfeature branch.","title":"Step 8: Create a pull request"},{"location":"how-to-contribute/#step-9-get-a-code-review","text":"Once your pull request has been opened, it will be assigned to at least one reviewers. Those reviewers will do a thorough code review, looking for correctness, bugs, opportunities for improvement, documentation and comments, and style. Commit changes made in response to review comments to the same branch on your fork. Very small PRs are easy to review. Very large PRs are very difficult to review.","title":"Step 9: Get a code review"},{"location":"nGQL-tutorial/","text":"nGQL Query Language \u00b6 nGQL is the query language of Nebula Graph that allows users to store and retrieve data from the graph database. Nebula Graph wants to make its queries easy to learn, understand, and use for everyone. Key attributes of nGQL \u00b6 Nebula Graph is committed to create a new query language that specifically deals with graph data. nGQL has two attributes that are not available together in any other query language out there. Declarative: nGQL is a declarative query language, which is very different from the imperative alternatives out there. You declare the pattern that you are looking for. You effectively tell nGQL what you want, rather than how to get it. Expressive: nGQL's ASCII-art style syntax provides a familiar, readable way to match patterns of nodes and relationships within graph datasets. nGQL Syntax \u00b6 nGQL key words are case-insensitive but we recommend them written in all caps for easy reading. To help you get a quick understanding of nGQL, we have created a simple graph myspace_test with 4 vertices and 3 edges. Cluster administration \u00b6 Add hosts Add a single host ADD HOSTS $storage_ip:$storage_port Add multiple hosts ADD HOSTS $storage_ip1:$storage_port1, $storage_ip2:$storage_port2,... Note: Replace the $storage_ip and $storage_port here according to the local_ip and port in nebula-storaged.conf. Separate the hosts by comma. For example: ADD HOSTS 192.168.8.5:65500 Show hosts SHOW HOSTS ============================= | Ip | Port | Status | ============================= | 192.168.8.5 | 65500 | online | ----------------------- | 192.168.8.1 | 65500 | offline | ----------------------- Remove hosts Remove a single host REMOVE HOSTS $storage_ip:$storage_port Remove multiple hosts REMOVE HOSTS $storage_ip1:$storage_port1, $storage_ip2:$storage_port2,... Note: Separate the hosts by comma. Graph administration \u00b6 Graph spaces are physically isolated like the database in MySQL. CREATE DROP USE DESCRIBE SHOW SPACE \u221a \u221a \u221a v0.2 \u221a Create space with CREATE, drop space with DROP, choose which space to use with USE, list available spaces with SHOW. DESCRIBE will be released in v0.2. Following are some examples: List all the spaces available SHOW SPACES ================ | Name | ================ | myspace_test | ---------------- Drop a space DROP SPACE myspace_test Note: DROP SPACE deletes all data in the current version and recovery is not supported yet. Create a space CREATE SPACE myspace_test(partition_num=10, replica_factor=1) Note: partition_num is used to control the number of shardings and replica_factor to control the number of raft copies, which is set to 1 when in stand-alone version. Specify space USE myspace_test Schema mutation \u00b6 Schema is used to manage the properties of vertices and edges (name and type of each field). In Nebula, a vertex can be labeled by multiple tags. CREATE DROP ALTER DESCRIBE SHOW TTL LOAD DUMP TAG \u221a v0.2 v0.2 \u221a \u221a v0.3 v0.2 v0.3 EDGE \u221a v0.2 v0.2 \u221a \u221a v0.3 v0.2 v0.3 You can use CREATE, DROP, ALTER, DESCRIBE to create, drop, alter, view a schema. Following are some examples: CREATE TAG player(name string, age int); DESCRIBE TAG player; CREATE TAG team(name string); DESCRIBE TAG team; CREATE EDGE serve (start_year int, end_year int); DESCRIBE EDGE serve; CREATE EDGE like (likeness double); SHOW TAGS; SHOW EDGES Data manipulation \u00b6 INSERT is used to insert new vertices and edges, UPDATE AND REMOVE will be available in v0.2. INSERT UPDATE REMOVE TAG \u221a v0.2 v0.2 EDGE \u221a v0.2 v0.2 When inserting a vertex, its tag type and attribute fields should be specified, while its ID can either be auto-generated by hash or specified manually. Following are some examples: INSERT VERTEX player(name, age) VALUES 100:(\"Stoudemire\", 36); -- specify ID manually INSERT VERTEX player(name, age) VALUES hash(\"Jummy\"):(\"Jummy\", 0); -- ID generated by hash INSERT VERTEX player(name, age) VALUES 101:(\"Vicenta\", 0); INSERT VERTEX team(name) VALUES 201:(\"Magic\"); INSERT EDGE like (likeness) VALUES 100 -> 101:(90.02); INSERT EDGE like (likeness) VALUES 101 -> 102:(10.00); INSERT EDGE serve (start_year, end_year) VALUES 101 -> 201:(2002, 2010); Graph query \u00b6 The most commonly used graph query/traversal operator is GO, it means starting from a certain point and querying its 1 degree neighbor. Complex queries can be done by combining pipe | , filtering WHERE , YIELD , etc. Following are some examples: GO FROM 100 OVER like; -- Start from vertex 100, query 1-hop along edge like. GO 2 STEPS FROM 100 OVER like; -- Start from vertex 100, query 2-hop along edge GO FROM 100 OVER like WHERE likeness >= 0; -- Start from vertex 100, query along edge like and filter its property likeness GO FROM 100 OVER like WHERE $$.player.name==\"Vicenta\"; -- Filter requirement: the destination vertex name is \"Vicenta\" GO FROM 101 OVER serve YIELD serve._src AS src_id, $^.player.age AS src_propAge, serve._dst AS dst_id, $$.team.name AS dst_propName; -- Return the starting vertex id(renamed as srcid), source vertex property age, destination vertex id and its name GO FROM 100 OVER like | GO FROM $-.id OVER serve; -- Start from vertex 100, query 1-hop, set its output as the next query's input by using pipe","title":"nGQL Query Language"},{"location":"nGQL-tutorial/#ngql-query-language","text":"nGQL is the query language of Nebula Graph that allows users to store and retrieve data from the graph database. Nebula Graph wants to make its queries easy to learn, understand, and use for everyone.","title":"nGQL Query Language"},{"location":"nGQL-tutorial/#key-attributes-of-ngql","text":"Nebula Graph is committed to create a new query language that specifically deals with graph data. nGQL has two attributes that are not available together in any other query language out there. Declarative: nGQL is a declarative query language, which is very different from the imperative alternatives out there. You declare the pattern that you are looking for. You effectively tell nGQL what you want, rather than how to get it. Expressive: nGQL's ASCII-art style syntax provides a familiar, readable way to match patterns of nodes and relationships within graph datasets.","title":"Key attributes of nGQL"},{"location":"nGQL-tutorial/#ngql-syntax","text":"nGQL key words are case-insensitive but we recommend them written in all caps for easy reading. To help you get a quick understanding of nGQL, we have created a simple graph myspace_test with 4 vertices and 3 edges.","title":"nGQL Syntax"},{"location":"nGQL-tutorial/#cluster-administration","text":"Add hosts Add a single host ADD HOSTS $storage_ip:$storage_port Add multiple hosts ADD HOSTS $storage_ip1:$storage_port1, $storage_ip2:$storage_port2,... Note: Replace the $storage_ip and $storage_port here according to the local_ip and port in nebula-storaged.conf. Separate the hosts by comma. For example: ADD HOSTS 192.168.8.5:65500 Show hosts SHOW HOSTS ============================= | Ip | Port | Status | ============================= | 192.168.8.5 | 65500 | online | ----------------------- | 192.168.8.1 | 65500 | offline | ----------------------- Remove hosts Remove a single host REMOVE HOSTS $storage_ip:$storage_port Remove multiple hosts REMOVE HOSTS $storage_ip1:$storage_port1, $storage_ip2:$storage_port2,... Note: Separate the hosts by comma.","title":"Cluster administration"},{"location":"nGQL-tutorial/#graph-administration","text":"Graph spaces are physically isolated like the database in MySQL. CREATE DROP USE DESCRIBE SHOW SPACE \u221a \u221a \u221a v0.2 \u221a Create space with CREATE, drop space with DROP, choose which space to use with USE, list available spaces with SHOW. DESCRIBE will be released in v0.2. Following are some examples: List all the spaces available SHOW SPACES ================ | Name | ================ | myspace_test | ---------------- Drop a space DROP SPACE myspace_test Note: DROP SPACE deletes all data in the current version and recovery is not supported yet. Create a space CREATE SPACE myspace_test(partition_num=10, replica_factor=1) Note: partition_num is used to control the number of shardings and replica_factor to control the number of raft copies, which is set to 1 when in stand-alone version. Specify space USE myspace_test","title":"Graph administration"},{"location":"nGQL-tutorial/#schema-mutation","text":"Schema is used to manage the properties of vertices and edges (name and type of each field). In Nebula, a vertex can be labeled by multiple tags. CREATE DROP ALTER DESCRIBE SHOW TTL LOAD DUMP TAG \u221a v0.2 v0.2 \u221a \u221a v0.3 v0.2 v0.3 EDGE \u221a v0.2 v0.2 \u221a \u221a v0.3 v0.2 v0.3 You can use CREATE, DROP, ALTER, DESCRIBE to create, drop, alter, view a schema. Following are some examples: CREATE TAG player(name string, age int); DESCRIBE TAG player; CREATE TAG team(name string); DESCRIBE TAG team; CREATE EDGE serve (start_year int, end_year int); DESCRIBE EDGE serve; CREATE EDGE like (likeness double); SHOW TAGS; SHOW EDGES","title":"Schema mutation"},{"location":"nGQL-tutorial/#data-manipulation","text":"INSERT is used to insert new vertices and edges, UPDATE AND REMOVE will be available in v0.2. INSERT UPDATE REMOVE TAG \u221a v0.2 v0.2 EDGE \u221a v0.2 v0.2 When inserting a vertex, its tag type and attribute fields should be specified, while its ID can either be auto-generated by hash or specified manually. Following are some examples: INSERT VERTEX player(name, age) VALUES 100:(\"Stoudemire\", 36); -- specify ID manually INSERT VERTEX player(name, age) VALUES hash(\"Jummy\"):(\"Jummy\", 0); -- ID generated by hash INSERT VERTEX player(name, age) VALUES 101:(\"Vicenta\", 0); INSERT VERTEX team(name) VALUES 201:(\"Magic\"); INSERT EDGE like (likeness) VALUES 100 -> 101:(90.02); INSERT EDGE like (likeness) VALUES 101 -> 102:(10.00); INSERT EDGE serve (start_year, end_year) VALUES 101 -> 201:(2002, 2010);","title":"Data manipulation"},{"location":"nGQL-tutorial/#graph-query","text":"The most commonly used graph query/traversal operator is GO, it means starting from a certain point and querying its 1 degree neighbor. Complex queries can be done by combining pipe | , filtering WHERE , YIELD , etc. Following are some examples: GO FROM 100 OVER like; -- Start from vertex 100, query 1-hop along edge like. GO 2 STEPS FROM 100 OVER like; -- Start from vertex 100, query 2-hop along edge GO FROM 100 OVER like WHERE likeness >= 0; -- Start from vertex 100, query along edge like and filter its property likeness GO FROM 100 OVER like WHERE $$.player.name==\"Vicenta\"; -- Filter requirement: the destination vertex name is \"Vicenta\" GO FROM 101 OVER serve YIELD serve._src AS src_id, $^.player.age AS src_propAge, serve._dst AS dst_id, $$.team.name AS dst_propName; -- Return the starting vertex id(renamed as srcid), source vertex property age, destination vertex id and its name GO FROM 100 OVER like | GO FROM $-.id OVER serve; -- Start from vertex 100, query 1-hop, set its output as the next query's input by using pipe","title":"Graph query"},{"location":"nGQL/","text":"Nebula Graph Query Language (nGQL) \u00b6 About nGQL \u00b6 nGQL is a declarative, textual query language like SQL, but for graphs. Unlike SQL, nGQL is all about expressing graph patterns. nGQL is a work in progress. We will add more features and further simplify the existing ones. There might be inconsistency between the syntax specs and implementation for the time being. Goals \u00b6 Easy to learn Easy to understand To focus on the online queries, also to provide the foundation for the offline computation Features \u00b6 Syntax is close to SQL, but not exactly the same (Easy to learn) Expandable Case insensitive Support basic graph traverse Support pattern match Support aggregation Support graph mutation Support distributed transaction (future release) Statement composition, but NO statement embedding (Easy to read) Prerequisite \u00b6 Directed property graph with schema Terminology \u00b6 Graph Space : A physically isolated space for different graph Tag : A label associated with a list of properties Each tag has a name (human readable string), and internally each tag will be assigned a 32-bit integer Each tag associates with a list of properties, each property has a name and a type There could be dependencies between tags. The dependency is a constrain, for instance, if tag S depends on tag T, then tag S cannot exist unless tag T exists Vertex : A Node in the graph Each vertex has a unique 64-bit (signed integer) ID ( VID ) Each vertex can associate with multiple tags Edge : A Link between two vertices Each edge can be uniquely identified by a tuple Edge type (ET) is a human readable string, internally it will be assigned a 32-bit integer. The edge type decides the property list (schema) on the edge Edge rank is an immutable user-assigned 64-bit signed integer. It affects the edge order between two vertices. The edge with a higher rank value comes first. When not specified, the default rank value is zero Each edge can only be of one type Path : A non-forked connection with multiple vertices and edges between them The length of a path is the number of the edges on the path, which is one less than the number of vertices A path can be represented by a list of vertices, edge types, and rank. An edge is a special path with length==1 <vid, edge_type[:rank], vid, ...> Language Specification \u00b6 General \u00b6 The entire set of statements can be categorized into three classes: query , mutation , and administration Every statement can yield a data set as the result. Each data set contains a schema (column name and type) and multiple data rows Composition \u00b6 Statements could be composed in two ways: Statements could be piped together using operator \" | \", much like the pipe in the shell scripts. The result yielded from the previous statement could be redirected to the next statement as input More than one statements can be batched together, separated by \" ; \". The result of the last statement (or a RETURN statement is executed) will be returned as the result of the batch Data Types \u00b6 Simple type: vid , integer (int64), double , float , bool , string , path , timestamp , year , month (year/month), date , datetime vid : 64-bit signed integer, representing a vertex ID List of simple types, such as integer[] , double[] , string[] Map : A list of KV pairs. The key must be a string , the value must be the same type for the given map Object (future release??): A list of KV pairs. The key mush be a string , the value can be any simple type Tuple List : This is only used for return values . It's composed by both meta data and data (multiple rows). The meta data includes the column names and their types. Type Conversion \u00b6 A simple typed value can be implicitly converted into a list A list can be implicitly converted into a one-column tuple list \"<type>_list\" can be used as the column name Common BNF \u00b6 ::= vid | integer | double | float | bool | string | path | timestamp | year | month | date | datetime ::= ::= | ::= vid (, vid )* | \"{\" vid (, vid )* \"}\" <label> ::= [:alpha] ([:alnum:] | \"_\")* ::= (\"_\")* <label> ::= <label> ::= (, )* ::= :<type> ::= \":\" ::= ::= <tuple> (, <tuple>)* | \"{\" <tuple> (, <tuple>)* \"}\" <tuple> ::= \"(\" VALUE (, VALUE )* \")\" <var> ::= \"$\" <label> Statements \u00b6 Choose a graph space \u00b6 Nebula supports multiple graph spaces. Data in different graph spaces are physically isolated. Before executing a query, a graph space needs to be selected using the following statement USE Return a data set \u00b6 Simply return a single value or a data set RETURN ::= vid | | | <var> Create a tag \u00b6 The following statement defines a new tag CREATE TAG ( ) ::= ::= + ::= , ::= Modify a tag type \u00b6 Create an edge type \u00b6 The following statement defines a new edge type CREATE EDGE ( ) := <label> Modify an edge type \u00b6 Insert vertices \u00b6 The following statement inserts one or more vertices INSERT VERTEX [ NO OVERWRITE ] VALUES ::= ( ) (, ( ))* ::= :( ) (, :( ))* ::= vid ::= (, )* ::= VALUE (, VALUE )* Insert edges \u00b6 The following statement inserts one or more edges INSERT EDGE [ NO OVERWRITE ] [( )] VALUES ( )+ edge_value ::= -> [@ ] : Update a vertex \u00b6 The following statement updates a vertex UPDATE VERTEX SET \\ [ WHERE ] [ YIELD ] ::= | ::= = {, = }+ ::= ( ) = ( ) | ( ) = Update an edge \u00b6 The following statement updates an edge UPDATE EDGE -> [@ ] OF SET [ WHERE ] [ YIELD ] Traverse the graph \u00b6 Navigate from given vertices to their neighbors according to the given conditions. It returns either a list of vertex IDs, or a list of tuples GO [ STEPS ] FROM [ OVER [ REVERSELY ] ] [ WHERE ] [ YIELD ] ::= integer | integer TO integer | UPTO integer ::= [data_set] [[ AS ] ] ::= vid | | | ::= [ AS ] ::= {, }* ::= ::= { AND | OR }\\* ::= > | >= | < | <= | == | != | IN ::= {, }* ::= [ AS ] WHERE clause only applies to the results that are going to be returned. It will not be applied to the intermediate results (See the detail description of the STEP[S] clause) When STEP[S] clause is skipped, it implies one step When going out for one step from the given vertex, all neighbors will be checked against the WHERE clause, only results satisfied the WHERE clause will be returned When going out for more than one step, WHERE clause will only be applied to the final results. It will not be applied to the intermediate results. Here is an example GO 2 STEPS FROM me OVER friend WHERE birthday > \"1988/1/1\" Obviously, you will probably guess the meaning of the query is to get all my fof (friend of friend) whose birthday is after 1988/1/1. You are absolutely right. We will not apply the filter to my friends (in the first step) Here is another example GO UPTO 3 STEPS FROM me OVER friend WHERE birthday > \"1988/1/1/\" This query tries to find any friend of me whose birthday is after 1988/1/1. If it finds at least one, it will return all the results. If it cannot find any, it will check my friends of friends to see if anyone's birthday is after 1988/1/1. It will return all the non-empty results, otherwise it will check my friends of friends of friends. So, similarly, next query tries to find anyone whose birthday is after 1988/1/1 starting from my 3-hop friends, and finishing at my 5-hop friends GO 3 TO 5 STEPS FROM me OVER friend WHERE birthday > \"1988/1/1/\" Search \u00b6 Following statements looks for vertices or edges that match certain conditions FIND VERTEX WHERE [ YIELD ] FIND EDGE WHERE [ YIELD ] Pattern match \u00b6 The following statement does a pattern match, and can return tuple list or paths MATCH [ FROM ] [ WHERE ] [ YIELD ] Property Reference \u00b6 It's common to refer a property in the statement, such as in WHERE clause and YIELD clause. In nGQL, the reference to a property is defined as ::= \".\" ::= | | ::= ::= '[' \"]\" <var> always starts with \"$\". There are two special variables: $- and $$. $- refers to the input stream, while $$ refers to the destination objects All property names start with a letter. There are a few system property names starting with \"_\". All properties names starting with \"_\" are reserved. Here are some built-in properties: _id : Vertex id _type : Edge type _src : Source ID of the edge _dst : Destination ID of the edge _rank : Edge rank unuber","title":"Nebula Graph Query Language (nGQL)"},{"location":"nGQL/#nebula-graph-query-language-ngql","text":"","title":"Nebula Graph Query Language (nGQL)"},{"location":"nGQL/#about-ngql","text":"nGQL is a declarative, textual query language like SQL, but for graphs. Unlike SQL, nGQL is all about expressing graph patterns. nGQL is a work in progress. We will add more features and further simplify the existing ones. There might be inconsistency between the syntax specs and implementation for the time being.","title":"About nGQL"},{"location":"nGQL/#goals","text":"Easy to learn Easy to understand To focus on the online queries, also to provide the foundation for the offline computation","title":"Goals"},{"location":"nGQL/#features","text":"Syntax is close to SQL, but not exactly the same (Easy to learn) Expandable Case insensitive Support basic graph traverse Support pattern match Support aggregation Support graph mutation Support distributed transaction (future release) Statement composition, but NO statement embedding (Easy to read)","title":"Features"},{"location":"nGQL/#prerequisite","text":"Directed property graph with schema","title":"Prerequisite"},{"location":"nGQL/#terminology","text":"Graph Space : A physically isolated space for different graph Tag : A label associated with a list of properties Each tag has a name (human readable string), and internally each tag will be assigned a 32-bit integer Each tag associates with a list of properties, each property has a name and a type There could be dependencies between tags. The dependency is a constrain, for instance, if tag S depends on tag T, then tag S cannot exist unless tag T exists Vertex : A Node in the graph Each vertex has a unique 64-bit (signed integer) ID ( VID ) Each vertex can associate with multiple tags Edge : A Link between two vertices Each edge can be uniquely identified by a tuple Edge type (ET) is a human readable string, internally it will be assigned a 32-bit integer. The edge type decides the property list (schema) on the edge Edge rank is an immutable user-assigned 64-bit signed integer. It affects the edge order between two vertices. The edge with a higher rank value comes first. When not specified, the default rank value is zero Each edge can only be of one type Path : A non-forked connection with multiple vertices and edges between them The length of a path is the number of the edges on the path, which is one less than the number of vertices A path can be represented by a list of vertices, edge types, and rank. An edge is a special path with length==1 <vid, edge_type[:rank], vid, ...>","title":"Terminology"},{"location":"nGQL/#language-specification","text":"","title":"Language Specification"},{"location":"nGQL/#general","text":"The entire set of statements can be categorized into three classes: query , mutation , and administration Every statement can yield a data set as the result. Each data set contains a schema (column name and type) and multiple data rows","title":"General"},{"location":"nGQL/#composition","text":"Statements could be composed in two ways: Statements could be piped together using operator \" | \", much like the pipe in the shell scripts. The result yielded from the previous statement could be redirected to the next statement as input More than one statements can be batched together, separated by \" ; \". The result of the last statement (or a RETURN statement is executed) will be returned as the result of the batch","title":"Composition"},{"location":"nGQL/#data-types","text":"Simple type: vid , integer (int64), double , float , bool , string , path , timestamp , year , month (year/month), date , datetime vid : 64-bit signed integer, representing a vertex ID List of simple types, such as integer[] , double[] , string[] Map : A list of KV pairs. The key must be a string , the value must be the same type for the given map Object (future release??): A list of KV pairs. The key mush be a string , the value can be any simple type Tuple List : This is only used for return values . It's composed by both meta data and data (multiple rows). The meta data includes the column names and their types.","title":"Data Types"},{"location":"nGQL/#type-conversion","text":"A simple typed value can be implicitly converted into a list A list can be implicitly converted into a one-column tuple list \"<type>_list\" can be used as the column name","title":"Type Conversion"},{"location":"nGQL/#common-bnf","text":"::= vid | integer | double | float | bool | string | path | timestamp | year | month | date | datetime ::= ::= | ::= vid (, vid )* | \"{\" vid (, vid )* \"}\" <label> ::= [:alpha] ([:alnum:] | \"_\")* ::= (\"_\")* <label> ::= <label> ::= (, )* ::= :<type> ::= \":\" ::= ::= <tuple> (, <tuple>)* | \"{\" <tuple> (, <tuple>)* \"}\" <tuple> ::= \"(\" VALUE (, VALUE )* \")\" <var> ::= \"$\" <label>","title":"Common BNF"},{"location":"nGQL/#statements","text":"","title":"Statements"},{"location":"nGQL/#choose-a-graph-space","text":"Nebula supports multiple graph spaces. Data in different graph spaces are physically isolated. Before executing a query, a graph space needs to be selected using the following statement USE","title":"Choose a graph space"},{"location":"nGQL/#return-a-data-set","text":"Simply return a single value or a data set RETURN ::= vid | | | <var>","title":"Return a data set"},{"location":"nGQL/#create-a-tag","text":"The following statement defines a new tag CREATE TAG ( ) ::= ::= + ::= , ::=","title":"Create a tag"},{"location":"nGQL/#modify-a-tag-type","text":"","title":"Modify a tag type"},{"location":"nGQL/#create-an-edge-type","text":"The following statement defines a new edge type CREATE EDGE ( ) := <label>","title":"Create an edge type"},{"location":"nGQL/#modify-an-edge-type","text":"","title":"Modify an edge type"},{"location":"nGQL/#insert-vertices","text":"The following statement inserts one or more vertices INSERT VERTEX [ NO OVERWRITE ] VALUES ::= ( ) (, ( ))* ::= :( ) (, :( ))* ::= vid ::= (, )* ::= VALUE (, VALUE )*","title":"Insert vertices"},{"location":"nGQL/#insert-edges","text":"The following statement inserts one or more edges INSERT EDGE [ NO OVERWRITE ] [( )] VALUES ( )+ edge_value ::= -> [@ ] :","title":"Insert edges"},{"location":"nGQL/#update-a-vertex","text":"The following statement updates a vertex UPDATE VERTEX SET \\ [ WHERE ] [ YIELD ] ::= | ::= = {, = }+ ::= ( ) = ( ) | ( ) =","title":"Update a vertex"},{"location":"nGQL/#update-an-edge","text":"The following statement updates an edge UPDATE EDGE -> [@ ] OF SET [ WHERE ] [ YIELD ]","title":"Update an edge"},{"location":"nGQL/#traverse-the-graph","text":"Navigate from given vertices to their neighbors according to the given conditions. It returns either a list of vertex IDs, or a list of tuples GO [ STEPS ] FROM [ OVER [ REVERSELY ] ] [ WHERE ] [ YIELD ] ::= integer | integer TO integer | UPTO integer ::= [data_set] [[ AS ] ] ::= vid | | | ::= [ AS ] ::= {, }* ::= ::= { AND | OR }\\* ::= > | >= | < | <= | == | != | IN ::= {, }* ::= [ AS ] WHERE clause only applies to the results that are going to be returned. It will not be applied to the intermediate results (See the detail description of the STEP[S] clause) When STEP[S] clause is skipped, it implies one step When going out for one step from the given vertex, all neighbors will be checked against the WHERE clause, only results satisfied the WHERE clause will be returned When going out for more than one step, WHERE clause will only be applied to the final results. It will not be applied to the intermediate results. Here is an example GO 2 STEPS FROM me OVER friend WHERE birthday > \"1988/1/1\" Obviously, you will probably guess the meaning of the query is to get all my fof (friend of friend) whose birthday is after 1988/1/1. You are absolutely right. We will not apply the filter to my friends (in the first step) Here is another example GO UPTO 3 STEPS FROM me OVER friend WHERE birthday > \"1988/1/1/\" This query tries to find any friend of me whose birthday is after 1988/1/1. If it finds at least one, it will return all the results. If it cannot find any, it will check my friends of friends to see if anyone's birthday is after 1988/1/1. It will return all the non-empty results, otherwise it will check my friends of friends of friends. So, similarly, next query tries to find anyone whose birthday is after 1988/1/1 starting from my 3-hop friends, and finishing at my 5-hop friends GO 3 TO 5 STEPS FROM me OVER friend WHERE birthday > \"1988/1/1/\"","title":"Traverse the graph"},{"location":"nGQL/#search","text":"Following statements looks for vertices or edges that match certain conditions FIND VERTEX WHERE [ YIELD ] FIND EDGE WHERE [ YIELD ]","title":"Search"},{"location":"nGQL/#pattern-match","text":"The following statement does a pattern match, and can return tuple list or paths MATCH [ FROM ] [ WHERE ] [ YIELD ]","title":"Pattern match"},{"location":"nGQL/#property-reference","text":"It's common to refer a property in the statement, such as in WHERE clause and YIELD clause. In nGQL, the reference to a property is defined as ::= \".\" ::= | | ::= ::= '[' \"]\" <var> always starts with \"$\". There are two special variables: $- and $$. $- refers to the input stream, while $$ refers to the destination objects All property names start with a letter. There are a few system property names starting with \"_\". All properties names starting with \"_\" are reserved. Here are some built-in properties: _id : Vertex id _type : Edge type _src : Source ID of the edge _dst : Destination ID of the edge _rank : Edge rank unuber","title":"Property Reference"}]}